# üîê Authentication Flow: Backend & Frontend Guide

## üìã Quick Summary

**Your Backend**: Uses industry-standard **token rotation** with dual support for web (HttpOnly cookies) and mobile (secure storage).

**Your Frontend**: Must handle tokens differently based on platform:
- **Web Apps** ‚Üí Browser manages refresh token automatically via HttpOnly cookies
- **Mobile Apps** ‚Üí Must store and update refresh token in secure storage

---

## üéØ What Your Backend Does

### 1. Login/Registration (`POST /api/v1/auth/verify-login`)

**Backend Behavior:**

```typescript
// When user logs in with phone + verification code
1. ‚úÖ Validates verification code
2. ‚úÖ Creates/finds user in database
3. ‚úÖ Generates TWO tokens:
   - Access Token (15 minutes) ‚Üí Short-lived for API calls
   - Refresh Token (30 days) ‚Üí Long-lived for getting new access tokens
4. ‚úÖ Stores refresh token in database with metadata (device, IP, user agent)
5. ‚úÖ Detects client type (web vs mobile)
6. ‚úÖ Responds differently based on client:

   // For WEB CLIENTS (default)
   - Sets refresh token as HttpOnly cookie (browser stores it)
   - Sets hasAuth=1 cookie (readable by JavaScript)
   - Returns only access token in response body
   
   // For MOBILE CLIENTS (header: x-client-type: mobile)
   - Returns BOTH tokens in response body
   - No cookies set
```

**Response for Web:**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": { "id": "...", "phoneNumber": "...", ... },
    "tokens": {
      "accessToken": "eyJhbGc...",
      "expiresIn": 900
      // ‚ùå No refreshToken (it's in HttpOnly cookie)
    }
  }
}
```

**Response for Mobile:**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": { "id": "...", "phoneNumber": "...", ... },
    "tokens": {
      "accessToken": "eyJhbGc...",
      "refreshToken": "eyJhbGc...",  // ‚úÖ Included for mobile
      "expiresIn": 900,
      "refreshExpiresIn": 2592000
    }
  }
}
```

---

### 2. Token Refresh (`POST /api/v1/auth/refresh`)

**Backend Behavior:**

```typescript
// When access token expires and needs refresh
1. ‚úÖ Detects client type:
   - Web: Looks for refresh token in HttpOnly cookie
   - Mobile: Looks for refresh token in request body
   
2. ‚úÖ Validates refresh token:
   - Checks JWT signature
   - Checks if token exists in database
   - Checks if token is revoked
   - Checks if token is expired
   - Checks if user is still active
   
3. ‚úÖ REVOKES old refresh token (token rotation security)
   - Marks old token as isRevoked: true in database
   - This prevents token reuse if stolen
   
4. ‚úÖ Generates NEW token pair:
   - New access token (15 minutes)
   - New refresh token (30 days)
   
5. ‚úÖ Stores new refresh token in database

6. ‚úÖ Responds based on client type:
   - Web: Sets new refresh token cookie + returns access token
   - Mobile: Returns BOTH tokens in body
```

**Request from Web:**
```typescript
// Frontend does NOT send refresh token manually
fetch('http://api.example.com/api/v1/auth/refresh', {
  method: 'POST',
  credentials: 'include' // ‚ö†Ô∏è CRITICAL: Browser sends cookie automatically
})
```

**Request from Mobile:**
```typescript
// Frontend MUST send refresh token in body
fetch('http://api.example.com/api/v1/auth/refresh', {
  method: 'POST',
  headers: { 
    'x-client-type': 'mobile',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    refreshToken: 'eyJhbGc...' // From secure storage
  })
})
```

**Response for Web:**
```json
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "tokens": {
      "accessToken": "eyJhbGc...",  // New access token
      "expiresIn": 900
      // ‚ùå No refreshToken (it's in new HttpOnly cookie)
    }
  }
}
```

**Response for Mobile:**
```json
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "tokens": {
      "accessToken": "eyJhbGc...",      // New access token
      "refreshToken": "eyJhbGc...",     // ‚úÖ NEW refresh token (must update!)
      "expiresIn": 900,
      "refreshExpiresIn": 2592000
    }
  }
}
```

---

### 3. Token Rotation Explained

**‚ùó CRITICAL CONCEPT: Your backend implements token rotation**

```
User logs in:
‚îú‚îÄ Backend generates: RefreshToken_v1
‚îú‚îÄ Backend stores: RefreshToken_v1 (isRevoked: false)
‚îî‚îÄ User receives: RefreshToken_v1

15 minutes later, access token expires...
User calls refresh:
‚îú‚îÄ User sends: RefreshToken_v1
‚îú‚îÄ Backend validates: RefreshToken_v1 ‚úÖ
‚îú‚îÄ Backend generates: RefreshToken_v2 (new)
‚îú‚îÄ Backend REVOKES: RefreshToken_v1 (isRevoked: true) ‚Üê OLD TOKEN DEAD!
‚îú‚îÄ Backend stores: RefreshToken_v2 (isRevoked: false)
‚îî‚îÄ User receives: RefreshToken_v2

If user tries to use RefreshToken_v1 again:
‚îî‚îÄ Backend rejects: "Refresh token is invalid or expired" ‚ùå

User must use RefreshToken_v2 for next refresh
```

**Why Token Rotation?**
- üîí **Security**: Stolen tokens become useless after one use
- üîç **Detection**: If old token is reused, indicates compromise
- ‚è±Ô∏è **Limited Window**: Even if stolen, attacker has limited time

---

## üíª What Your Frontend Should Do

### For Web Apps (React, Vue, Angular, etc.)

#### 1. Configure HTTP Client

```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:3001/api/v1',
  withCredentials: true // ‚ö†Ô∏è CRITICAL: Sends/receives cookies
});

export default api;
```

#### 2. Store Tokens Correctly

```typescript
// ‚úÖ CORRECT: Access token in memory only
let accessToken: string | null = null;

export const setAccessToken = (token: string | null) => {
  accessToken = token;
};

export const getAccessToken = () => accessToken;

// ‚ùå WRONG: Never use localStorage for tokens (XSS risk)
localStorage.setItem('accessToken', token); // DON'T DO THIS!

// ‚ùå WRONG: Don't try to access refresh token
document.cookie; // Won't see refreshToken (it's HttpOnly)
```

#### 3. Login Flow

```typescript
const login = async (phoneNumber: string, code: string) => {
  const response = await api.post('/auth/verify-login', {
    phoneNumber,
    verificationCode: code
  });

  // Store access token in memory
  setAccessToken(response.data.data.tokens.accessToken);
  
  // ‚úÖ Refresh token is in HttpOnly cookie (automatic)
  // ‚úÖ Browser will send it automatically on every request
  // ‚ùå Don't try to read or store it manually

  return response.data.data.user;
};
```

#### 4. Automatic Token Refresh (Axios Interceptor)

```typescript
let isRefreshing = false;
let refreshSubscribers: Array<(token: string) => void> = [];

// Add access token to all requests
api.interceptors.request.use((config) => {
  const token = getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Auto-refresh on 401
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Queue this request
        return new Promise((resolve) => {
          refreshSubscribers.push((token: string) => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            resolve(api(originalRequest));
          });
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Call refresh - cookie sent automatically
        const response = await api.post('/auth/refresh');
        const newAccessToken = response.data.data.tokens.accessToken;

        // Update access token in memory
        setAccessToken(newAccessToken);

        // Process queued requests
        refreshSubscribers.forEach((callback) => callback(newAccessToken));
        refreshSubscribers = [];

        // Retry failed request
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed - logout
        setAccessToken(null);
        window.location.href = '/login';
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);
```

#### 5. What You DON'T Need to Do (Web)

```typescript
// ‚ùå DON'T manually manage refresh token
// ‚ùå DON'T send refresh token in request body
// ‚ùå DON'T store refresh token anywhere
// ‚ùå DON'T update refresh token after refresh

// ‚úÖ Browser does ALL of this automatically!
```

---

### For Mobile Apps (React Native, Flutter, etc.)

#### 1. Configure HTTP Client

```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com/api/v1',
  headers: {
    'x-client-type': 'mobile' // ‚ö†Ô∏è CRITICAL: Tells backend you're mobile
  }
});

export default api;
```

#### 2. Store Tokens Securely

```typescript
import * as SecureStore from 'expo-secure-store';

const TokenStorage = {
  // Access Token
  async saveAccessToken(token: string) {
    await SecureStore.setItemAsync('accessToken', token);
  },
  
  async getAccessToken() {
    return await SecureStore.getItemAsync('accessToken');
  },
  
  // Refresh Token
  async saveRefreshToken(token: string) {
    // ‚ö†Ô∏è CRITICAL: Must use secure storage (encrypted)
    await SecureStore.setItemAsync('refreshToken', token);
  },
  
  async getRefreshToken() {
    return await SecureStore.getItemAsync('refreshToken');
  },
  
  async clearAll() {
    await SecureStore.deleteItemAsync('accessToken');
    await SecureStore.deleteItemAsync('refreshToken');
  }
};

// ‚ùå WRONG: Never use AsyncStorage for tokens (not encrypted)
AsyncStorage.setItem('refreshToken', token); // DON'T DO THIS!
```

#### 3. Login Flow

```typescript
const login = async (phoneNumber: string, code: string) => {
  const response = await api.post('/auth/verify-login', {
    phoneNumber,
    verificationCode: code
  });

  const { accessToken, refreshToken } = response.data.data.tokens;

  // ‚ö†Ô∏è CRITICAL: Store BOTH tokens securely
  await TokenStorage.saveAccessToken(accessToken);
  await TokenStorage.saveRefreshToken(refreshToken);

  return response.data.data.user;
};
```

#### 4. Automatic Token Refresh

```typescript
let isRefreshing = false;
let refreshSubscribers: Array<(token: string) => void> = [];

// Add access token to all requests
api.interceptors.request.use(async (config) => {
  const token = await TokenStorage.getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Auto-refresh on 401
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        return new Promise((resolve) => {
          refreshSubscribers.push((token: string) => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            resolve(api(originalRequest));
          });
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Get refresh token from secure storage
        const refreshToken = await TokenStorage.getRefreshToken();
        
        if (!refreshToken) {
          throw new Error('No refresh token');
        }

        // ‚ö†Ô∏è CRITICAL: Send refresh token in body
        const response = await api.post('/auth/refresh', {
          refreshToken
        });

        const { accessToken, refreshToken: newRefreshToken } = 
          response.data.data.tokens;

        // ‚ö†Ô∏è CRITICAL: Update BOTH tokens
        await TokenStorage.saveAccessToken(accessToken);
        await TokenStorage.saveRefreshToken(newRefreshToken); // NEW token!

        // Process queued requests
        refreshSubscribers.forEach((callback) => callback(accessToken));
        refreshSubscribers = [];

        // Retry failed request
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed - logout
        await TokenStorage.clearAll();
        // Navigate to login screen
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);
```

#### 5. What You MUST Do (Mobile)

```typescript
// ‚úÖ MUST send x-client-type: mobile header
// ‚úÖ MUST store refresh token in secure storage
// ‚úÖ MUST send refresh token in request body
// ‚úÖ MUST update BOTH tokens after refresh
// ‚úÖ MUST use encrypted storage (SecureStore/Keychain/Keystore)
```

---

## üîç Key Differences: Web vs Mobile

| Aspect | Web Apps | Mobile Apps |
|--------|----------|-------------|
| **Refresh Token Storage** | HttpOnly Cookie (browser) | Secure Storage (encrypted) |
| **Refresh Token Sending** | Automatic (cookie) | Manual (request body) |
| **Client Detection** | Default | Header: `x-client-type: mobile` |
| **Login Response** | Access token only | Both tokens |
| **Refresh Response** | Access token only | Both tokens (NEW) |
| **Token Update** | Automatic (browser) | Manual (must save new token) |
| **Security Model** | XSS protection via HttpOnly | Encryption via secure storage |

---

## üö® Common Mistakes & Solutions

### Mistake 1: Reusing Old Refresh Token

```typescript
// ‚ùå WRONG: Using same refresh token repeatedly
const refreshToken = 'abc123';
await refresh(refreshToken); // Works
await refresh(refreshToken); // ‚ùå FAILS - token was revoked!

// ‚úÖ CORRECT: Updating refresh token after each refresh
let currentToken = 'abc123';
const result1 = await refresh(currentToken);
currentToken = result1.refreshToken; // Update!

const result2 = await refresh(currentToken);
currentToken = result2.refreshToken; // Update again!
```

### Mistake 2: Not Sending Credentials (Web)

```typescript
// ‚ùå WRONG: Cookies won't be sent
axios.get('/api/users');

// ‚úÖ CORRECT: Cookies are sent
axios.get('/api/users', { withCredentials: true });

// OR set globally
axios.defaults.withCredentials = true;
```

### Mistake 3: Storing Tokens Insecurely (Mobile)

```typescript
// ‚ùå WRONG: Not encrypted (anyone can read)
AsyncStorage.setItem('refreshToken', token);

// ‚úÖ CORRECT: Encrypted storage
SecureStore.setItemAsync('refreshToken', token);
```

### Mistake 4: Not Detecting Client Type

```typescript
// ‚ùå WRONG: Mobile app without header
const api = axios.create({
  baseURL: 'https://api.example.com'
});

// ‚úÖ CORRECT: Mobile app with header
const api = axios.create({
  baseURL: 'https://api.example.com',
  headers: { 'x-client-type': 'mobile' }
});
```

### Mistake 5: Storing Access Token in localStorage (Web)

```typescript
// ‚ùå WRONG: Vulnerable to XSS attacks
localStorage.setItem('accessToken', token);

// ‚úÖ CORRECT: Memory only (React state, Zustand, Redux)
const [accessToken, setAccessToken] = useState(null);
```

---

## üìä Complete Flow Diagram

### Web App Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. LOGIN                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Frontend                    Backend                    Browser
      ‚îÇ                           ‚îÇ                           ‚îÇ
      ‚îÇ‚îÄ‚îÄPOST /auth/verify-login‚îÄ‚îÄ>                          ‚îÇ
      ‚îÇ  {phone, code}            ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ Generate tokens          ‚îÇ
      ‚îÇ                           ‚îÇ - accessToken (15min)    ‚îÇ
      ‚îÇ                           ‚îÇ - refreshToken (30d)     ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄResponse‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                          ‚îÇ
      ‚îÇ  {accessToken}            ‚îÇ‚îÄSet-Cookie: refreshToken‚îÄ>
      ‚îÇ                           ‚îÇ  (HttpOnly, Secure)      ‚îÇ
      ‚îÇ                           ‚îÇ‚îÄSet-Cookie: hasAuth=1‚îÄ‚îÄ‚îÄ‚îÄ>
      ‚îÇ                           ‚îÇ                          ‚îÇ
   Store accessToken              ‚îÇ                    Stores cookies
   in memory (React)              ‚îÇ                    automatically


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. API CALL (15 minutes later, access token expired)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Frontend                    Backend                    Browser
      ‚îÇ                           ‚îÇ                           ‚îÇ
      ‚îÇ‚îÄ‚îÄGET /api/users‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>                          ‚îÇ
      ‚îÇ  Auth: Bearer [EXPIRED]   ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ401 Unauthorized‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ‚îÄ‚îÄPOST /auth/refresh‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>                          ‚îÇ
      ‚îÇ  (no body)                ‚îÇ<‚îÄCookie: refreshToken‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ                           ‚îÇ  (automatic)             ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ                           ‚îÇ Validate refresh token   ‚îÇ
      ‚îÇ                           ‚îÇ Revoke old token         ‚îÇ
      ‚îÇ                           ‚îÇ Generate new tokens      ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄResponse‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                          ‚îÇ
      ‚îÇ  {newAccessToken}         ‚îÇ‚îÄSet-Cookie: NEW refresh‚îÄ‚îÄ>
      ‚îÇ                           ‚îÇ  (automatic rotation)    ‚îÇ
      ‚îÇ                           ‚îÇ                          ‚îÇ
   Update accessToken             ‚îÇ                    Updates cookie
   in memory                      ‚îÇ                    automatically
      ‚îÇ                           ‚îÇ                          ‚îÇ
      ‚îÇ‚îÄ‚îÄGET /api/users (retry)‚îÄ‚îÄ‚îÄ>                          ‚îÇ
      ‚îÇ  Auth: Bearer [NEW]       ‚îÇ                          ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ200 OK‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                          ‚îÇ


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ KEY POINT: Frontend never touches refresh token!                ‚îÇ
‚îÇ Browser manages it automatically via cookies.                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Mobile App Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. LOGIN                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Frontend                         Backend
      ‚îÇ                                ‚îÇ
      ‚îÇ‚îÄ‚îÄPOST /auth/verify-login‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
      ‚îÇ  Header: x-client-type: mobile ‚îÇ
      ‚îÇ  {phone, code}                 ‚îÇ
      ‚îÇ                                ‚îÇ
      ‚îÇ                                ‚îÇ Generate tokens
      ‚îÇ                                ‚îÇ Detect mobile client
      ‚îÇ                                ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄResponse‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ  {                             ‚îÇ
      ‚îÇ    accessToken,                ‚îÇ
      ‚îÇ    refreshToken  ‚Üê‚îÄ‚îÄ Both!     ‚îÇ
      ‚îÇ  }                             ‚îÇ
      ‚îÇ                                ‚îÇ
   Save BOTH to SecureStore            ‚îÇ
   (encrypted storage)                 ‚îÇ


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. API CALL (15 minutes later, access token expired)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Frontend                         Backend
      ‚îÇ                                ‚îÇ
      ‚îÇ‚îÄ‚îÄGET /api/users‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
      ‚îÇ  Auth: Bearer [EXPIRED]        ‚îÇ
      ‚îÇ                                ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ401 Unauthorized‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ                                ‚îÇ
   Get refreshToken                    ‚îÇ
   from SecureStore                    ‚îÇ
      ‚îÇ                                ‚îÇ
      ‚îÇ‚îÄ‚îÄPOST /auth/refresh‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
      ‚îÇ  Header: x-client-type: mobile ‚îÇ
      ‚îÇ  {                             ‚îÇ
      ‚îÇ    refreshToken ‚Üê‚îÄ‚îÄ Send it!   ‚îÇ
      ‚îÇ  }                             ‚îÇ
      ‚îÇ                                ‚îÇ
      ‚îÇ                                ‚îÇ Validate refresh token
      ‚îÇ                                ‚îÇ Revoke old token
      ‚îÇ                                ‚îÇ Generate new tokens
      ‚îÇ                                ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄResponse‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ  {                             ‚îÇ
      ‚îÇ    accessToken,                ‚îÇ
      ‚îÇ    refreshToken (NEW!)         ‚îÇ
      ‚îÇ  }                             ‚îÇ
      ‚îÇ                                ‚îÇ
   Save BOTH NEW tokens                ‚îÇ
   to SecureStore                      ‚îÇ
      ‚îÇ                                ‚îÇ
      ‚îÇ‚îÄ‚îÄGET /api/users (retry)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>
      ‚îÇ  Auth: Bearer [NEW]            ‚îÇ
      ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ200 OK‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ KEY POINT: Frontend MUST update refresh token after each        ‚îÇ
‚îÇ refresh because backend rotates it (old one is revoked).        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ Implementation Checklist

### Backend (Already Done ‚úÖ)

- [x] Token rotation on refresh
- [x] HttpOnly cookies for web clients
- [x] Token in body for mobile clients
- [x] Client type detection
- [x] Database storage of refresh tokens
- [x] Token revocation system
- [x] Device tracking
- [x] Audit logging

### Frontend - Web

- [ ] Configure `withCredentials: true`
- [ ] Store access token in memory only
- [ ] Never store refresh token (browser handles it)
- [ ] Implement axios interceptor for auto-refresh
- [ ] Handle 401 errors with refresh logic
- [ ] Clear tokens on logout
- [ ] Never use localStorage for tokens

### Frontend - Mobile

- [ ] Send `x-client-type: mobile` header
- [ ] Use secure storage (SecureStore/Keychain)
- [ ] Store BOTH tokens after login
- [ ] Send refresh token in request body
- [ ] Update BOTH tokens after refresh
- [ ] Clear secure storage on logout
- [ ] Never use AsyncStorage for tokens

---

## üÜò Troubleshooting

### Error: "Refresh token is invalid or expired"

**Causes:**
1. ‚ùå Reusing old refresh token after refresh (token rotation)
2. ‚ùå Token actually expired (30 days passed)
3. ‚ùå Token was revoked by logout
4. ‚ùå User was deactivated

**Solutions:**
1. ‚úÖ Update refresh token after each refresh (mobile)
2. ‚úÖ Let browser handle cookie update (web)
3. ‚úÖ Redirect to login if refresh fails

### Web: Cookies Not Being Sent

**Causes:**
1. ‚ùå Missing `withCredentials: true`
2. ‚ùå CORS not configured for credentials
3. ‚ùå Different domain (localhost vs 127.0.0.1)

**Solutions:**
1. ‚úÖ Set `withCredentials: true` in axios
2. ‚úÖ Backend CORS: `credentials: true`
3. ‚úÖ Use consistent domain/port

### Mobile: Token Not Updating

**Causes:**
1. ‚ùå Not saving new refresh token after refresh
2. ‚ùå Missing `x-client-type: mobile` header
3. ‚ùå Backend returning web-style response

**Solutions:**
1. ‚úÖ Save both tokens after refresh
2. ‚úÖ Always send mobile header
3. ‚úÖ Backend correctly detects client type

---

## üìö Additional Resources

- Your existing guides:
  - `FRONTEND_TOKEN_REFRESH_GUIDE.md` - Web implementation details
  - `INDUSTRY_BEST_PRACTICES.md` - Complete security patterns
  - `BACKEND_AUTH_VERIFICATION.md` - API endpoint specifications

- Industry standards:
  - [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
  - [OAuth 2.0 Best Practices](https://oauth.net/2/best-practices/)
  - [Auth0 Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)

---

**Questions?** Review the detailed guides above or contact the development team.


